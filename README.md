# Spring Security Lab

A lab environment for experiments with Spring Security.

## Usage

Use `git checkout master` to reset this project back to the defaults and start a new lab. From here, create a new branch for your experiment and name it something appropriate like

```
git checkout -b jwt-lab
```

Add documentation to this README when your lab is complete.

## Labs

### http-basic

Out of the box Spring Boot uses HTTP Basic authentication. All we've done is add a resource exposed under `/resource` that returns a string

```
curl localhost:8080/resource
```

If you try to access the resource, you get

```json
{"timestamp":1512834033044,"status":401,"error":"Unauthorized","message":"Full authentication is required to access this resource","path":"/resource"}
```

The Spring Boot default is to protect all urls with HTTP Basic, so we need to pass the user name and the autogenerated password. The way to do this is to use the -u flag. Look at the log in the console for the password. You should see a line like this

```
Using default security password: 81329475-5b42-4cfc-a6a8-5172b14b7ab1
```

so we simply pass that password in with the default user name 'user':

```
curl -u user:81329475-5b42-4cfc-a6a8-5172b14b7ab1 localhost:8080/resource 
```

and you should see the string "resource" returned. Pretty boring example, but we'll get more involved as we go.

#### How Does It Work

The default Spring Boot Security configuration is described [here](https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-security).

The short answer is there is an in-memory user store that is initialized with the single user and a randomly generated password on start up. User stores in Spring Security implement the interface `UserDetailsService`, which has a single method 

#### Customizing the Autoconfigured Authentication Manager

Let's set the credentials for the single user with user name 'user'. Open the application.yml file and type security followed by tab. You will see all of the properties for configuring the default in memory user details service. For example, we can change the default user name and password with:

```yaml
security:
  user:
    name: chase
    password: changeme
```

Restart the service and try to access the resource with

```
curl -u chase:changeme localhost:8080/resource
```

#### Customizing the Protected URL Pattern

A common pattern in web services that sit directly behind web applications is to separate API requests by prefixing the url with `/api`. Suppose we do this with our service and change the route to `/api/resource`. I may only want to secure endpoints that begin with `/api` and have everything else unsecured. To do this we use the `security.basic.path` property in our application.yml:

```yaml
security:
  user:
    name: chase
    password: changeme
    
  basic:
    path:
    - "/api/**"
```

Let's add an unprotected resource under `/unprotected`. Since this doesn't start with `/api` we can access it with the usual curl command

```
curl localhost:8080/unprotected
unprotected
```

but we can't get to our `/api/resource` without authenticating as before

```
curl localhost:8080/api/resource
{"timestamp":1513019493411,"status":401,"error":"Unauthorized","message":"Full authentication is required to access this resource","path":"/api/resource"}

# try again
curl -u chase:changeme localhost:8080/api/resource
resource
```

#### Customizing the Role

A `Principal` authenticated in Spring Security can have a list of granted authorities that determine what they are allowed to do in the application. In addition to being authenticated, I could require that a user has the **admin** authority to access the `/admin/**` paths. To do this, we need another `SecurityFilterChain`.

```java
@Bean
	public WebSecurityConfigurerAdapter adminWebSecurity() {
		return new WebSecurityConfigurerAdapter() {
			@Override
			protected void configure(HttpSecurity http) throws Exception {				
				http.authorizeRequests()
					.antMatchers("/api/admin/**")
					.hasRole("ADMIN")
					.and()
					.httpBasic()
					.and()
					.csrf().disable()
					.sessionManagement()
					.sessionCreationPolicy(SessionCreationPolicy.STATELESS); 				
			}
		};	
	}
```

Notice what this does from the log. You should be able to see that we get a new filter chain 

```
2017-12-11 14:04:10.790  INFO 24777 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Creating filter chain: org.springframework.security.web.util.matcher.AnyRequestMatcher@1, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@38499e48, org.springframework.security.web.context.SecurityContextPersistenceFilter@1ec7d8b3, org.springframework.security.web.header.HeaderWriterFilter@534ca02b, org.springframework.security.web.authentication.logout.LogoutFilter@3b152928, org.springframework.security.web.authentication.www.BasicAuthenticationFilter@c3fa05a, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@5bb3131b, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@516ebdf8, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@4905c46b, org.springframework.security.web.session.SessionManagementFilter@736ac09a, org.springframework.security.web.access.ExceptionTranslationFilter@66908383, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@301d8120]
```

The `FilterChainProxy` class will apply the first matching filter chain in its list of `SecurityFilterChain`s, in this case, we got lucky because our most specific pattern comes before the more generic chain matching `/api/**`. This is due to the Spring Boot autoconfiguration.

Now add the ADMIN role to our user

```yaml
security:
  user:
    name: chase
    password: changeme
    role:
    - ADMIN
    
  basic:
    path:
    - "/api/**"
```

and try to access the `/api/admin/resource` url

```
curl -u chase:changeme localhost:8080/api/admin/resource
admin resource
```

If we remove the role and bounce the service, you should see

```
curl -u chase:changeme localhost:8080/api/admin/resource
{"timestamp":1513023056712,"status":403,"error":"Forbidden","message":"Access is denied","path":"/api/admin/resource"}
```

after retrying the request. The 401 code we received above was because we hadn't authenticated. In this case, we get a 403 to indicate the user was authenticated but doesn't have the right permissions.

#### More Users and Various Roles

Now the Spring Boot autoconfiguration and the `security.*` properties are limited to this one user. To do anything interesting we probably need at least one user per application defined role. The beauty of Spring and dependency injection is that we can preserve everything Spring Boot does out of the box, and define what we need by injecting it into the application context:

```java
@Bean
public UserDetailsService inMemoryUserDetails() {
	
	InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
	
	inMemoryUserDetailsManager.createUser(		
		User.withUsername("chase")
			.password("chase")
			.roles("ADMIN")
			.build()
	);
	
	inMemoryUserDetailsManager.createUser(
		User.withUsername("john")
			.password("john")
			.roles("USER")
			.build()
	);
	
	inMemoryUserDetailsManager.createUser(
		User.withUsername("sara")
			.password("sara")
			.roles("USER")
			.build()
	);
	
	return inMemoryUserDetailsManager;
	
}
```

Try the service out with any of these user/role combinations to convince yourself that they have been added to the user service:

```
curl -u john:john localhost:8080/api/resource
resource for john

curl -u john:john localhost:8080/api/admin/resource
{"timestamp":1513025662442,"status":403,"error":"Forbidden","message":"Access is denied","path":"/api/admin/resource"}

curl -u chase:chase localhost:8080/api/admin/resource
admin resource
```

All we've done here is created multiple users/roles in an `InMemoryUserDetailsManager`. This is a `UserDetailsService` backed by a `Map` in memory. This service will get injected into the `AuthenticationManager`, which in turn is injected into the `BasicAuthenticationFilter`. 

Having users in-memory is great for testing and debugging. If you think about it, we have exercised a large piece of the Spring Security framework up to this point: UserDetails, AuthenticationManager, roles and grant authorities, principals, etc. If you were doing this in production, instead of an `InMemoryUserDetailsManager`, you would have your own custom implementation of the `UserDetailsService` that would connect to a database of users. Again, dependency injection would allow you to simply inject this custom implementation into the context when needed, and use the in-memory version for local testing. The security logic is the same no matter which implementation allowing you to focus on the users and roles, and what they can access.

##### Challenge

Expose an endpoint that allows any ADMIN to change the role of another user.
 

## References

[Spring Security Reference](https://docs.spring.io/spring-security/site/docs/5.0.0.RELEASE/reference/htmlsingle/)
